#!/usr/bin/python3

"""
Part of the SqueezeMeta distribution. 06/08/2019 Original version,
                            (c) Fernando Puente-Sánchez, CNB-CSIC.

Combine tabular outputs (as generated by sqm2tables.py from different
 SqueezeMeta projects.

This script can combine the results of different samples ran using the 
 sequential mode, in which each sample is run separately, and also the
 results of different coassembly or merged SqueezeMeta runs.


USAGE:
usage: combine-sqm-tables.py [-h] PROJECT_PATHS
                             [-o OUTPUT_DIR] [-p OUTPUT_PREFIX]
                             [--trusted-functions] [--ignore-unclassified]
                             project_paths [project_paths ...]

OPTIONS:
    -o/--output-dir: Name of the output directory
    -p/--output-prefix: Prefix for the output files
    --trusted-functions: Include only ORFs with highly trusted KEGG and
        COG assignments in aggregated functional tables
    --ignore-unclassified: Ignore ORFs without assigned functions in
        TPM calculation


"""

from os.path import abspath, dirname, realpath
from os import mkdir
from os.path import isfile, isdir
from sys import exit
import argparse
from subprocess import call

from pandas import DataFrame

from sys import path
utils_home = abspath(dirname(realpath(__file__)))
SQMpath = abspath('%s/../'.format(utils_home))


def main(args):

    ### Create output dir.
    try:
       mkdir(args.output_dir)
    except OSError as e:
        if e.errno != 17:
            raise
        else:
            print('\nThe directory {} already exists. Please remove it or use a different output name.\n'.format(args.output_dir))
            exit(1)


    sampleNames = []

    superkingdom = {}
    phylum = {}
    class_ = {}
    order = {}
    family = {}
    genus = {}
    species = {}

    KOabund = {}
    KOcopy = {}
    KOtpm = {}

    COGabund = {}
    COGcopy = {}
    COGtpm = {}

    PFAMabund = {}
    PFAMcopy = {}
    PFAMtpm = {}

    for projPath in args.project_paths:
        projName = projPath.split('/')[-1]
        if not isfile('{}/SqueezeMeta_conf.pl'.format(projPath)):
            raise Exception('Path "{}" does not exist, or does not contain a valid SQM project'.format(projPath))
        if not isdir('{}/results/tables'.format(projPath)):
            print('Creating tables for project {}'.format(projName))
            command = ['{}/utils/sqm2tables.py'.format(SQMhome), '{}'.format(projpath), '{}/results/tables'.format(projPath)]
            if args.trusted_functions:
                command.append('--trusted-functions')
            if args.ignore_unclassified:
                command.append('--ignore-unclassified')
            call(command)
        else:
            print('The "{}/results/tables" is already present. Skipping...'.format(projPath))
        
        samples = parse_table('{}/results/tables/{}.superkingdom.allfilter.abund.tsv'.format(projPath, projName), superkingdom)
        sampleNames.extend(samples)

        parse_table('{}/results/tables/{}.phylum.allfilter.abund.tsv'.format(projPath, projName), phylum)
        parse_table('{}/results/tables/{}.class.allfilter.abund.tsv'.format(projPath, projName), class_)
        parse_table('{}/results/tables/{}.order.allfilter.abund.tsv'.format(projPath, projName), order)
        parse_table('{}/results/tables/{}.family.allfilter.abund.tsv'.format(projPath, projName), family)
        parse_table('{}/results/tables/{}.genus.allfilter.abund.tsv'.format(projPath, projName), genus)
        parse_table('{}/results/tables/{}.species.allfilter.abund.tsv'.format(projPath, projName), species)

        parse_table('{}/results/tables/{}.KO.abund.tsv'.format(projPath, projName), KOabund)
        parse_table('{}/results/tables/{}.KO.copyNumber.tsv'.format(projPath, projName), KOcopy)
        parse_table('{}/results/tables/{}.KO.tpm.tsv'.format(projPath, projName), KOtpm)

        parse_table('{}/results/tables/{}.COG.abund.tsv'.format(projPath, projName), COGabund)
        parse_table('{}/results/tables/{}.COG.copyNumber.tsv'.format(projPath, projName), COGcopy)
        parse_table('{}/results/tables/{}.COG.tpm.tsv'.format(projPath, projName), COGtpm)

        parse_table('{}/results/tables/{}.PFAM.abund.tsv'.format(projPath, projName), PFAMabund)
        parse_table('{}/results/tables/{}.PFAM.copyNumber.tsv'.format(projPath, projName), PFAMcopy)
        parse_table('{}/results/tables/{}.PFAM.tpm.tsv'.format(projPath, projName), PFAMtpm)


    prefix = '{}/{}.'.format(args.output_dir, args.output_prefix)

    write_feature_dict(sampleNames, superkingdom, prefix + 'superkingdom.abund.tsv')
    write_feature_dict(sampleNames, phylum, prefix + 'phylum.abund.tsv')
    write_feature_dict(sampleNames, class_, prefix + 'class.abund.tsv')
    write_feature_dict(sampleNames, order, prefix + 'order.abund.tsv')
    write_feature_dict(sampleNames, family, prefix + 'family.abund.tsv')
    write_feature_dict(sampleNames, genus, prefix + 'genus.abund.tsv')
    write_feature_dict(sampleNames, species, prefix + 'species.abund.tsv')

    write_feature_dict(sampleNames, KOabund, prefix + 'KO.abund.tsv')
    write_feature_dict(sampleNames, KOcopy, prefix + 'KO.copyNumber.tsv')
    write_feature_dict(sampleNames, KOtpm, prefix + 'KO.tpm.tsv')

    write_feature_dict(sampleNames, COGabund, prefix + 'COG.abund.tsv')
    write_feature_dict(sampleNames, COGcopy, prefix + 'COG.copyNumber.tsv')
    write_feature_dict(sampleNames, COGtpm, prefix + 'COG.tpm.tsv')

    write_feature_dict(sampleNames, PFAMabund, prefix + 'PFAM.abund.tsv')
    write_feature_dict(sampleNames, PFAMcopy, prefix + 'PFAM.copyNumber.tsv')
    write_feature_dict(sampleNames, PFAMtpm, prefix + 'PFAM.tpm.tsv')



def parse_table(path, targetDict):
    """
    Inserts a set of samples from a table in a dictionary.
    The dictionary is modified in place.
    Returns a list with the names of the samples.
    """
    with open(path) as infile:
        samples = infile.readline().strip().split('\t')
        for sample in samples:
            if sample in targetDict:
                raise Exception('Error where parsing table in "{}". Sample "{}" appears more than once in your input tables.'.format(path, sample))
            targetDict[sample] = {}
        for line in infile:
            line = line.strip().split('\t')
            feature = line[0]
            for sample, value in zip(samples, line[1:]):
                targetDict[sample][feature] = value
        return samples


def write_feature_dict(sampleNames, featureDict, outName):
    df = DataFrame.from_dict(featureDict)
    df = df.sort_index()
    df = df[sampleNames]
    df.to_csv(outName, sep='\t')



def parse_args():
    parser = argparse.ArgumentParser(description='Aggregate SqueezeMeta results into tables', epilog='Fernando Puente-Sánchez (CNB) 2019\n')
    parser.add_argument('project_paths', type=str, nargs='+', help='Base path of the SqueezeMeta projects to combine')
    parser.add_argument('-o', '--output-dir', type=str, default='combined', help='Output directory')
    parser.add_argument('-p', '--output-prefix', type=str, default='combined', help='Prefix for output files')
    parser.add_argument('--trusted-functions', action='store_true', help='Include only ORFs with highly trusted KEGG and COG assignments in aggregated functional tables')
    parser.add_argument('--ignore-unclassified', action='store_true', help='Ignore ORFs without assigned functions in TPM calculation')

    return parser.parse_args()


if __name__ == '__main__':
    main(parse_args())
