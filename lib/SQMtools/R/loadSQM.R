require(reshape2)

#' Load a SqueezeMeta project into R
#'
#' This function takes the path to a project directory generated by \href{http://github.com/jtamames/SqueezeMeta}{SqueezeMeta} (whose name is specified in the \code{-p} parameter of the SqueezeMeta.pl script) and parses the results into a SQM object
#'
#' @section Prerequisites:
#' {
#' \enumerate{
#'     \item Run \href{http://github.com/jtamames/SqueezeMeta}{SqueezeMeta}! An example call for running it would be:
#'
#'         \code{/path/to/SqueezeMeta -m coassembly -f fasta_dir -s samples_file -p project_dir }
#'     \item Generate tabular outputs with the \code{sqm2tables.py} script included in the \code{path/to/SqueezeMeta/utils} directory:
#'
#'         \code{/path/to/SqueezeMeta/utils/sqm2tables.py project_dir project_dir/results/tables}
#'     }
#' }
#' 
#' @section The SQM object structure:
#' {
#' The SQM object is a nested list which contains the following information:
#' \tabular{lllllll}{
#' \bold{lvl1}         \tab \bold{lvl2}             \tab \bold{lvl3}          \tab \bold{type}             \tab \bold{rows/names} \tab \bold{columns} \tab \bold{data}  \cr
#' \bold{$orfs}        \tab \bold{$table}           \tab                      \tab \emph{dataframe}        \tab orfs              \tab misc. data     \tab misc. data   \cr
#'                     \tab \bold{$abund}           \tab                      \tab \emph{numeric matrix}   \tab orfs              \tab samples        \tab abundances   \cr
#'                     \tab \bold{$tpm}             \tab                      \tab \emph{numeric matrix}   \tab orfs              \tab samples        \tab tpm          \cr
#'                     \tab \bold{$seqs}            \tab                      \tab \emph{character vector} \tab orfs              \tab (n/a)          \tab sequences    \cr
#'                     \tab \bold{$tax}             \tab                      \tab \emph{character matrix} \tab orfs              \tab tax. ranks     \tab taxonomy     \cr
#' \bold{$contigs}     \tab \bold{$table}           \tab                      \tab \emph{dataframe}        \tab contigs           \tab misc. data     \tab misc. data   \cr
#'                     \tab \bold{$abund}           \tab                      \tab \emph{numeric matrix}   \tab contigs           \tab samples        \tab abundances   \cr
#'                     \tab \bold{$tpm}             \tab                      \tab \emph{numeric matrix}   \tab contigs           \tab samples        \tab tpm          \cr
#'                     \tab \bold{$seqs}            \tab                      \tab \emph{character vector} \tab contigs           \tab (n/a)          \tab sequences    \cr
#'                     \tab \bold{$tax}             \tab                      \tab \emph{character matrix} \tab contigs           \tab tax. ranks     \tab taxonomies   \cr
#'                     \tab \bold{$bins}            \tab                      \tab \emph{character matrix} \tab contigs           \tab bin. methods   \tab bins         \cr
#' $bins               \tab \bold{$table}           \tab                      \tab \emph{dataframe}        \tab bins              \tab misc. data     \tab misc. data   \cr
#'                     \tab \bold{$tpm}             \tab                      \tab \emph{numeric matrix}   \tab bins              \tab samples        \tab tpm          \cr
#'                     \tab \bold{$tax}             \tab                      \tab \emph{character matrix} \tab bins              \tab tax. ranks     \tab taxonomy     \cr
#' \bold{$taxa}        \tab \bold{$superkingdom}    \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab superkingdoms     \tab samples        \tab abundances   \cr
#'                     \tab                         \tab \bold{$percent}      \tab \emph{numeric matrix}   \tab superkingdoms     \tab samples        \tab percentages  \cr
#'                     \tab \bold{$phylum}          \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab phyla             \tab samples        \tab abundances   \cr
#'                     \tab                         \tab \bold{$percent}      \tab \emph{numeric matrix}   \tab phyla             \tab samples        \tab percentages  \cr
#'                     \tab \bold{$class}           \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab classes           \tab samples        \tab abundances   \cr
#'                     \tab                         \tab \bold{$percent}      \tab \emph{numeric matrix}   \tab classes           \tab samples        \tab percentages  \cr
#'                     \tab \bold{$order}           \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab orders            \tab samples        \tab abundances   \cr
#'                     \tab                         \tab \bold{$percent}      \tab \emph{numeric matrix}   \tab orders            \tab samples        \tab percentages  \cr
#'                     \tab \bold{$family}          \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab families          \tab samples        \tab abundances   \cr
#'                     \tab                         \tab \bold{$percent}      \tab \emph{numeric matrix}   \tab families          \tab samples        \tab percentages  \cr
#'                     \tab \bold{$genus}           \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab genera            \tab samples        \tab abundances   \cr
#'                     \tab                         \tab \bold{$percent}      \tab \emph{numeric matrix}   \tab genera            \tab samples        \tab percentages  \cr
#'                     \tab \bold{$species}         \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab species           \tab samples        \tab abundances   \cr
#'                     \tab                         \tab \bold{$percent}      \tab \emph{numeric matrix}   \tab species           \tab samples        \tab percentages  \cr
#' \bold{$functions}   \tab \bold{$KEGG}            \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab KEGG ids          \tab samples        \tab abundances   \cr
#'                     \tab                         \tab \bold{$tpm}          \tab \emph{numeric matrix}   \tab KEGG ids          \tab samples        \tab tpm          \cr
#'                     \tab                         \tab \bold{$copy_number}  \tab \emph{numeric matrix}   \tab KEGG ids          \tab samples        \tab avg. copies  \cr
#'                     \tab \bold{$COG}             \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab COG ids           \tab samples        \tab abundances   \cr
#'                     \tab                         \tab \bold{$tpm}          \tab \emph{numeric matrix}   \tab COG ids           \tab samples        \tab tpm          \cr
#'                     \tab                         \tab \bold{$copy_number}  \tab \emph{numeric matrix}   \tab COG ids           \tab samples        \tab avg. copies  \cr
#'                     \tab \bold{$PFAM}            \tab \bold{$abund}        \tab \emph{numeric matrix}   \tab PFAM ids          \tab samples        \tab abundances   \cr
#'                     \tab                         \tab \bold{$tpm}          \tab \emph{numeric matrix}   \tab PFAM ids          \tab samples        \tab tpm          \cr
#'                     \tab                         \tab \bold{$copy_number}  \tab \emph{numeric matrix}   \tab PFAM ids          \tab samples        \tab avg. copies  \cr
#' \bold{$total_reads} \tab                         \tab                      \tab \emph{numeric vector}   \tab samples           \tab (n/a)          \tab total reads  \cr
#' \bold{$misc}        \tab \bold{$project_name}    \tab                      \tab \emph{character vector} \tab (empty)           \tab (n/a)          \tab project name \cr
#'                     \tab \bold{$samples}         \tab                      \tab \emph{character vector} \tab (empty)           \tab (n/a)          \tab samples      \cr
#'                     \tab \bold{$tax_names_long}  \tab \bold{$superkingdom} \tab \emph{character vector} \tab short names       \tab (n/a)          \tab full names   \cr
#'                     \tab                         \tab \bold{$phylum}       \tab \emph{character vector} \tab short names       \tab (n/a)          \tab full names   \cr
#'                     \tab                         \tab \bold{$class}        \tab \emph{character vector} \tab short names       \tab (n/a)          \tab full names   \cr
#'                     \tab                         \tab \bold{$order}        \tab \emph{character vector} \tab short names       \tab (n/a)          \tab full names   \cr
#'                     \tab                         \tab \bold{$family}       \tab \emph{character vector} \tab short names       \tab (n/a)          \tab full names   \cr
#'                     \tab                         \tab \bold{$genus}        \tab \emph{character vector} \tab short names       \tab (n/a)          \tab full names   \cr
#'                     \tab                         \tab \bold{$species}      \tab \emph{character vector} \tab short names       \tab (n/a)          \tab full names   \cr
#'                     \tab \bold{$tax_names_short} \tab                      \tab \emph{character vector} \tab full names        \tab (n/a)          \tab short names  \cr
#'                     \tab \bold{$KEGG_names}      \tab                      \tab \emph{character vector} \tab KEGG ids          \tab (n/a)          \tab KEGG names   \cr
#'                     \tab \bold{$COG_names}       \tab                      \tab \emph{character vector} \tab COG ids           \tab (n/a)          \tab COG names    \cr
#' }
#' }
#' @param project_path character, project directory generated by SqueezeMeta. 
#' @param tax_mode character, which taxonomic classification should be loaded? SqueezeMeta applies the identity thresholds described in \href{https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4005636/}{Luo \emph{et al.}, 2014}. Use \code{allfilter} for applying the minimum identity threshold to all taxa (default) and \code{prokfilter} for applying the threshold to Bacteria and Archaea, but not to Eukaryotes.
#' @return SQM object containing the parsed project.
#' @examples
#' \dontrun{
#' # (outside R)
#' /path/to/SqueezeMeta/scripts/SqueezeMeta.pl -p Hadza -f raw -m coassembly -s test.samples # Run SqueezeMeta on the test data
#' /path/to/SqueezeMeta/utils/sqm2tables.py Hadza Hadza/results/tables # Generate the tabular outputs! They must be placed in the <project name>/results/tables directory!
#' # now go into R
#' R
#' library(SQMtools)
#' Hadza = loadSQM("Hadza") # Where Hadza is the path to the SqueezeMeta output directory
#' }
#'
#' data(Hadza)
#' # Which are the ten most abundant KEGG IDs in our data?
#' topKEGG = sort(rowSums(Hadza$functions$KEGG$tpm), decreasing=T)[1:10]
#' # Which functions do those KEGG IDs represent?
#' Hadza$misc$KEGG_names[topKEGG]
#' What is the relative abundance of the Gammaproteobacteria class across samples?
#' Hadza$taxa$class$percent['Gammaproteobacteria',]
#' # Which information is stored in the orf, contig and bin tables?
#' colnames(Hadza$orfs$table)
#' colnames(Hadza$contigs$table)
#' colnames(Hadza$bins$table)
#' # What is the GC content distribution of my metagenome?
#' boxplot(Hadza$contigs$table[,'GC perc']) # Not weighted by contig length or abundance!
#' @export

loadSQM = function(project_path, tax_mode = 'allfilter')
    {
    
    if(!tax_mode %in% c('allfilter', 'prokfilter'))
        {
        stop('tax_mode must be either \'allfilter\' (apply minimum identity threshold for all taxa) or \'prokfilter\' (don\'t appy thresholds to Eukaryotes)')
        }

    # include my hierarchy somehow?? -> sqm2tables, aggregate KEGG hierarchy levels??
    
    SQM                           = list()
    
    project_name                  = tail(unlist(strsplit(project_path, split='/')), 1)
    SQM$misc                      = list()
    SQM$misc$project_name         = project_name

    cat('Loading orfs\n')
    SQM$orfs                      = list()

    cat('    table...\n')         # option to remove table from memory after getting abund & TPM?
    SQM$orfs$table                = read.table(sprintf('%s/results/13.%s.orftable', project_path, project_name),
                                               header=T, sep='\t', row.names=1, quote='', comment.char='', skip=1, as.is=TRUE, check.names=F)
    cat('    abundances...\n')
    SQM$orfs$abund                = as.matrix(SQM$orfs$table[,grepl('Raw read count', colnames(SQM$orfs$table)),drop=F])
    colnames(SQM$orfs$abund)      = gsub('Raw read count ', '', colnames(SQM$orfs$abund), fixed=T)
    SQM$orfs$cov                  = as.matrix(SQM$orfs$table[,grepl('Coverage', colnames(SQM$orfs$table)),drop=F])
    colnames(SQM$orfs$cov)        = gsub('Coverage ', '', colnames(SQM$orfs$cov), fixed=T)
    SQM$orfs$tpm                  = as.matrix(SQM$orfs$table[,grepl('TPM', colnames(SQM$orfs$table)),drop=F])
    colnames(SQM$orfs$tpm)        = gsub('TPM ', '', colnames(SQM$orfs$tpm), fixed=T)
    SQM$misc$samples              = colnames(SQM$orfs$abund)
    
    cat('    sequences\n')    
    SQM$orfs$seqs                 = read.namedvector(sprintf('%s/results/tables/%s.orf.sequences.tsv', project_path, project_name))
    
    cat('    taxonomy...\n')
    SQM$orfs$tax                  = as.matrix(read.table(sprintf('%s/results/tables/%s.orf.tax.%s.tsv', project_path, project_name, tax_mode),
                                                         header=T, row.names=1, sep='\t'))
    # Remove orfs with no nt length (which should be fixed at some point). The tax table contains the correct number of orfs.
    SQM$orfs$table                = SQM$orfs$table[rownames(SQM$orfs$table) %in% rownames(SQM$orfs$tax),]
    SQM$orfs$abund                = SQM$orfs$abund[rownames(SQM$orfs$table),,drop=F]
    SQM$orfs$tpm                  = SQM$orfs$tpm[rownames(SQM$orfs$table),,drop=F]
    SQM$orfs$seqs                 = SQM$orfs$seqs[rownames(SQM$orfs$table)[rownames(SQM$orfs$table) %in% names(SQM$orfs$seqs)]]
   
    # Load KEGG/COG names as misc data
    KEGGids                      = SQM$orfs$table[,'KEGG ID']
    KEGGids                      = gsub('*', '', KEGGids, fixed=T)
    KEGGnames                    = SQM$orfs$table[,'KEGGFUN']
    KEGGnames                    = KEGGnames[KEGGids!='' & !grepl(';', KEGGids, fixed=T)]
    SQM$misc$KEGG_names          = KEGGnames
    names(SQM$misc$KEGG_names)   = KEGGids  [KEGGids!='' & !grepl(';', KEGGids, fixed=T)]
    
    COGids                       = SQM$orfs$table[,'COG ID']
    COGids                       = gsub('*', '', COGids, fixed=T)
    COGnames                     = SQM$orfs$table[,'COGFUN']
    COGnames                     = COGnames[COGids!='' & !grepl(';', COGids, fixed=T)]
    SQM$misc$COG_names           = COGnames
    names(SQM$misc$COG_names)    = COGids  [COGids!='' & !grepl(';', COGids, fixed=T)]

    cat('Loading contigs\n')
    SQM$contigs                   = list()

    cat('    table...\n')                    # option to remove table from memory after getting abund & TPM?
    SQM$contigs$table             = read.table(sprintf('%s/results/20.%s.contigtable', project_path, project_name),
                                                       header=T, sep='\t', row.names=1, quote='', comment.char='', skip=1, as.is=T, check.names=F)
    cat('    abundances...\n')
    SQM$contigs$abund             = as.matrix(SQM$contigs$table[,grepl('Raw read count', colnames(SQM$contigs$table)),drop=F])
    colnames(SQM$contigs$abund)   = gsub('Raw read count ', '', colnames(SQM$contigs$abund), fixed=T)
    SQM$contigs$cov               = as.matrix(SQM$contigs$table[,grepl('Coverage', colnames(SQM$contigs$table)),drop=F])
    colnames(SQM$contigs$cov)     = gsub('Coverage ', '', colnames(SQM$contigs$cov), fixed=T)
    SQM$contigs$tpm               = as.matrix(SQM$contigs$table[,grepl('TPM', colnames(SQM$contigs$table)),drop=F])
    colnames(SQM$contigs$tpm)     = gsub('TPM ', '', colnames(SQM$contigs$tpm), fixed=T)

    cat('    sequences...\n')                                                 
    SQM$contigs$seqs              = read.namedvector(sprintf('%s/results/tables/%s.contig.sequences.tsv', project_path, project_name))
    SQM$contigs$seqs              = SQM$contigs$seqs[rownames(SQM$contigs$table)]

    cat('    taxonomy...\n')
    SQM$contigs$tax               = as.matrix(read.table(sprintf('%s/results/tables/%s.contig.tax.tsv', project_path, project_name),
                                                         header=T, row.names=1, sep='\t'))
    SQM$contigs$tax               = SQM$contigs$tax[rownames(SQM$contigs$table),]

    cat('    binning info...\n')
    inBins                        = read.table(sprintf('%s/intermediate/19.%s.contigsinbins', project_path, project_name),
                                               header=T, sep='\t', quote='', comment.char='', skip=1, as.is=T)
    inBins                        = reshape2::dcast(inBins, X..Contig~Method, value.var="Bin.ID")
    rownames(inBins)              = inBins[,1]
    SQM$contigs$bins              = as.matrix(inBins[,-1,drop=F])
    notInBins                     = setdiff(rownames(SQM$contigs$table), SQM$contigs$bins)
    notInBins                     = matrix(NA, nrow=length(notInBins), ncol=ncol(SQM$contigs$bins), dimnames=list(notInBins, colnames(SQM$contigs$bins)))
    SQM$contigs$bins              = rbind(SQM$contigs$bins, notInBins)
    SQM$contigs$bins              = SQM$contigs$bins[rownames(SQM$contigs$table),,drop=F]
    SQM$contigs$bins[is.na(SQM$contigs$bins)] = 'No_bin'
    names(SQM$contigs$bins)       = rownames(SQM$contigs$table)


    cat('Loading bins\n')
    cat('    table...\n')
    SQM$bins                      = list()
    SQM$bins$table                = read.table(sprintf('%s/results/19.%s.bintable', project_path, project_name),
                                               header=T, sep='\t', row.names=1, quote='', comment.char='', skip=1, as.is=T, check.names=F)
    cat('    abundances...\n')
    SQM$bins$tpm                  = as.matrix(SQM$bins$table[,grepl('TPM', colnames(SQM$bins$table)),drop=F])
    colnames(SQM$bins$tpm)        = gsub('TPM ', '', colnames(SQM$bins$tpm), fixed=T)
    cat('    taxonomy...\n')
    SQM$bins$taxonomy             = as.matrix(read.table(sprintf('%s/results/tables/%s.bin.tax.tsv', project_path, project_name),
                                                         header=T, row.names=1, sep='\t'))
    cat('Loading taxonomies\n')                                   
    SQM$taxa                      = list()
    SQM$taxa$superkingdom         = list()
    SQM$taxa$phylum               = list()
    SQM$taxa$class                = list()
    SQM$taxa$order                = list()
    SQM$taxa$family               = list()
    SQM$taxa$genus                = list()
    SQM$taxa$species              = list()
    

    SQM$taxa$superkingdom$abund   = as.matrix(read.table(sprintf('%s/results/tables/%s.superkingdom.%s.abund.tsv', project_path, project_name, tax_mode, project_name),
                                                         header=T, sep='\t', row.names=1, check.names=F))
    SQM$taxa$phylum$abund         = as.matrix(read.table(sprintf('%s/results/tables/%s.phylum.%s.abund.tsv', project_path, project_name, tax_mode),
                                                         header=T, sep='\t', row.names=1, check.names=F))
    SQM$taxa$class$abund          = as.matrix(read.table(sprintf('%s/results/tables/%s.class.%s.abund.tsv', project_path, project_name, tax_mode),
                                                         header=T, sep='\t', row.names=1, check.names=F))
    SQM$taxa$order$abund          = as.matrix(read.table(sprintf('%s/results/tables/%s.order.%s.abund.tsv', project_path, project_name, tax_mode),
                                                         header=T, sep='\t', row.names=1, check.names=F))
    SQM$taxa$family$abund         = as.matrix(read.table(sprintf('%s/results/tables/%s.family.%s.abund.tsv', project_path, project_name, tax_mode),
                                                         header=T, sep='\t', row.names=1, check.names=F))
    SQM$taxa$genus$abund          = as.matrix(read.table(sprintf('%s/results/tables/%s.genus.%s.abund.tsv', project_path, project_name, tax_mode),
                                                         header=T, sep='\t', row.names=1, check.names=F))
    SQM$taxa$species$abund        = as.matrix(read.table(sprintf('%s/results/tables/%s.species.%s.abund.tsv', project_path, project_name, tax_mode),
                                                         header=T, sep='\t', row.names=1, check.names=F))
                                                          
     
    SQM$taxa$superkingdom$percent = 100 * t(t(SQM$taxa$superkingdom$abund) / colSums(SQM$taxa$superkingdom$abund))
    SQM$taxa$phylum$percent       = 100 * t(t(SQM$taxa$phylum$abund)       / colSums(SQM$taxa$phylum$abund      ))
    SQM$taxa$class$percent        = 100 * t(t(SQM$taxa$class$abund)        / colSums(SQM$taxa$class$abund       )) 
    SQM$taxa$order$percent        = 100 * t(t(SQM$taxa$order$abund)        / colSums(SQM$taxa$order$abund       ))
    SQM$taxa$family$percent       = 100 * t(t(SQM$taxa$family$abund)       / colSums(SQM$taxa$family$abund      ))
    SQM$taxa$genus$percent        = 100 * t(t(SQM$taxa$genus$abund)        / colSums(SQM$taxa$genus$abund       ))
    SQM$taxa$species$percent      = 100 * t(t(SQM$taxa$species$abund)      / colSums(SQM$taxa$species$abund     ))

    
    SQM$misc$tax_names_long                 = list()

    SQM$misc$tax_names_long$superkingdom    = rownames(SQM$tax$superkingdom$abund)
    names(SQM$misc$tax_names_long$superkingdom) = gsub('^k_', '', SQM$misc$tax_names_long$superkingdom)

    SQM$misc$tax_names_long$phylum          = rownames(SQM$tax$phylum$abund)
    names(SQM$misc$tax_names_long$phylum)   = sapply(strsplit(SQM$misc$tax_names_long$phylum,  split=';p_'), FUN = function(x) x[2])

    SQM$misc$tax_names_long$class           = rownames(SQM$tax$class$abund)
    names(SQM$misc$tax_names_long$class)    = sapply(strsplit(SQM$misc$tax_names_long$class,   split=';c_'), FUN = function(x) x[2])

    SQM$misc$tax_names_long$order           = rownames(SQM$tax$order$abund)
    names(SQM$misc$tax_names_long$order)    = sapply(strsplit(SQM$misc$tax_names_long$order,   split=';o_'), FUN = function(x) x[2])

    SQM$misc$tax_names_long$family          = rownames(SQM$tax$family$abund)
    names(SQM$misc$tax_names_long$family)   = sapply(strsplit(SQM$misc$tax_names_long$family,  split=';f_'), FUN = function(x) x[2])

    SQM$misc$tax_names_long$genus           = rownames(SQM$tax$genus$abund)
    names(SQM$misc$tax_names_long$genus)    = sapply(strsplit(SQM$misc$tax_names_long$genus,   split=';g_'), FUN = function(x) x[2])

    SQM$misc$tax_names_long$species         = rownames(SQM$tax$species$abund)
    names(SQM$misc$tax_names_long$species)  = sapply(strsplit(SQM$misc$tax_names_long$species, split=';s_'), FUN = function(x) x[2]) 

    SQM$misc$tax_names_short                = unlist(lapply(SQM$misc$tax_names_long, names))
    names(SQM$misc$tax_names_short)         = unlist(SQM$misc$tax_names_long)


    # Use short names for taxonomy tables, since it makes it easier to search for specific taxa
    rownames(SQM$taxa$superkingdom$abund)   = SQM$misc$tax_names_short[rownames(SQM$taxa$superkingdom$abund)]
    rownames(SQM$taxa$phylum$abund)         = SQM$misc$tax_names_short[rownames(SQM$taxa$phylum$abund)]
    rownames(SQM$taxa$class$abund)          = SQM$misc$tax_names_short[rownames(SQM$taxa$class$abund)]
    rownames(SQM$taxa$order$abund)          = SQM$misc$tax_names_short[rownames(SQM$taxa$order$abund)]
    rownames(SQM$taxa$family$abund)         = SQM$misc$tax_names_short[rownames(SQM$taxa$family$abund)]
    rownames(SQM$taxa$genus$abund)          = SQM$misc$tax_names_short[rownames(SQM$taxa$genus$abund)]
    rownames(SQM$taxa$species$abund)        = SQM$misc$tax_names_short[rownames(SQM$taxa$species$abund)]

    rownames(SQM$taxa$superkingdom$percent) = SQM$misc$tax_names_short[rownames(SQM$taxa$superkingdom$percent)]
    rownames(SQM$taxa$phylum$percent)       = SQM$misc$tax_names_short[rownames(SQM$taxa$phylum$percent)]
    rownames(SQM$taxa$class$percent)        = SQM$misc$tax_names_short[rownames(SQM$taxa$class$percent)]
    rownames(SQM$taxa$order$percent)        = SQM$misc$tax_names_short[rownames(SQM$taxa$order$percent)]
    rownames(SQM$taxa$family$percent)       = SQM$misc$tax_names_short[rownames(SQM$taxa$family$percent)]
    rownames(SQM$taxa$genus$percent)        = SQM$misc$tax_names_short[rownames(SQM$taxa$genus$percent)]
    rownames(SQM$taxa$species$percent)      = SQM$misc$tax_names_short[rownames(SQM$taxa$species$percent)]


    cat('Loading functions\n')
    SQM$functions                  = list()
    SQM$functions$KEGG             = list()
    SQM$functions$KEGG$abund       = as.matrix(read.table(sprintf('%s/results/tables/%s.KO.abund.tsv', project_path, project_name),
                                                          header=T, sep='\t', row.names=1, check.names=F))
    SQM$functions$KEGG$tpm         = as.matrix(read.table(sprintf('%s/results/tables/%s.KO.tpm.tsv', project_path, project_name),
                                                          header=T, sep='\t', row.names=1, check.names=F))
                                                             
    SQM$functions$COG              = list()
    SQM$functions$COG$abund        = as.matrix(read.table(sprintf('%s/results/tables/%s.COG.abund.tsv', project_path, project_name),
                                                          header=T, sep='\t', row.names=1, check.names=F))
    SQM$functions$COG$tpm          = as.matrix(read.table(sprintf('%s/results/tables/%s.COG.tpm.tsv', project_path, project_name),
                                                          header=T, sep='\t', row.names=1, check.names=F))


    SQM$functions$PFAM             = list()
    SQM$functions$PFAM$abund       = as.matrix(read.table(sprintf('%s/results/tables/%s.PFAM.abund.tsv', project_path, project_name),
                                                          header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))
    SQM$functions$PFAM$tpm         = as.matrix(read.table(sprintf('%s/results/tables/%s.PFAM.tpm.tsv', project_path, project_name),
                                                          header=T, sep='\t', row.names=1, check.names=F, comment.char='', quote=''))

    if(file.exists(sprintf('%s/results/tables/%s.RecA.tsv', project_path, project_name)))
        {
        SQM$functions$KEGG$copy_number = as.matrix(read.table(sprintf('%s/results/tables/%s.KO.copyNumber.tsv', project_path, project_name),
                                                              header=T, sep='\t', row.names=1, check.names=F))
        SQM$functions$COG$copy_number  = as.matrix(read.table(sprintf('%s/results/tables/%s.COG.copyNumber.tsv', project_path, project_name),
                                                              header=T, sep='\t', row.names=1, check.names=F))
        SQM$functions$PFAM$copy_number = as.matrix(read.table(sprintf('%s/results/tables/%s.PFAM.copyNumber.tsv', project_path, project_name),
                                                              header=T, sep='\t', row.names=1, check.names=F))
        SQM$misc$RecA_cov              = unlist   (read.table(sprintf('%s/results/tables/%s.RecA.tsv', project_path, project_name),
                                                              header=T, row.names=1) ['COG0468',] )
    }else
        {
        warning('    There are no copy number tables in your project, possibly because COG annotation was not performed or RecA was not present in the metagenome')
        SQM$misc$RecA_cov              = NULL # Just being explicit here.
        }

    cat('Loading total reads\n')
    SQM$total_reads                = as.matrix(
                                               read.table(sprintf('%s/results/10.%s.mappingstat', project_path, project_name), 
                                                          header=T, sep='\t', row.names=1, skip=1, comment.char='')
                                              )[,'Total.reads']

    class(SQM)                     = 'SQM'

    return(SQM)

    }

